我来详细讲解简单选择排序算法。

选择排序的核心思想是：每次从未排序的部分选择最小的元素，放到已排序部分的末尾。

让我们通过代码和详细解释来理解：

```c
#include <stdio.h>

void selectionSort(int arr[], int n) {
    int i, j, min_idx;
    
    // 外层循环，每次确定一个位置的元素
    for (i = 0; i < n-1; i++) {
        // 假设当前位置的元素是最小的
        min_idx = i;
        
        // 在未排序部分找到最小元素
        for (j = i+1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        
        // 如果找到了更小的元素，就交换
        if (min_idx != i) {
            int temp = arr[i];
            arr[i] = arr[min_idx];
            arr[min_idx] = temp;
        }
    }
}
```

让我们以数组 [64, 25, 12, 22, 11] 为例，演示整个排序过程：

1. 第一次遍历：
   [64, 25, 12, 22, 11] → [11, 25, 12, 22, 64]
   找到最小值11，与第一个位置的64交换

2. 第二次遍历：
   [11, 25, 12, 22, 64] → [11, 12, 25, 22, 64]
   找到剩余部分最小值12，与第二个位置的25交换

3. 第三次遍历：
   [11, 12, 25, 22, 64] → [11, 12, 22, 25, 64]
   找到剩余部分最小值22，与第三个位置的25交换

4. 第四次遍历：
   [11, 12, 22, 25, 64]
   剩余部分已经有序，不需要交换

选择排序的特点：

1. 时间复杂度：
   - 最好情况：O(n²)
   - 最坏情况：O(n²)
   - 平均情况：O(n²)

2. 空间复杂度：O(1)
   - 只需要一个临时变量用于交换

3. 优点：
   - 实现简单，容易理解
   - 交换次数较少，最多进行n-1次交换
   - 当空间资源紧张时比较有优势

4. 缺点：
   - 时间复杂度固定为O(n²)，对输入数据不敏感
   - 不稳定排序算法（相等元素可能交换位置）

5. 适用场景：
   - 数据量较小的排序
   - 对稳定性没有要求的场合
   - 交换成本很高的场合

为了更清楚地看到排序过程，这里是一个完整的测试程序：

```c
#include <stdio.h>

void selectionSort(int arr[], int n);  // 上面已定义的排序函数

void printArray(int arr[], int n) {
    for(int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr)/sizeof(arr[0]);
    
    printf("原始数组: ");
    printArray(arr, n);
    
    selectionSort(arr, n);
    
    printf("排序后数组: ");
    printArray(arr, n);
    
    return 0;
}
```

改进建议：
1. 如果需要对大量数据排序，建议使用其他更高效的算法
2. 如果需要稳定排序，可以考虑使用插入排序或归并排序
3. 可以同时找最大值和最小值，每次循环确定两个位置，可以减少循环次数

您对选择排序还有什么想要了解的吗？
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgwMzMyMDE1M119
-->