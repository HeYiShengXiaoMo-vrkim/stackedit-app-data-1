## 基础概念
储存在计算机空间内的程序未被调用时叫做静态，调用之后变为动态，这些动态的计算机程序叫做进程，一个动态计算机程序内部可能会有多个顺序流在执行，叫做多线程，系统运行时会为每个进程分配不同的内存区域，但是不会为线程分配内存。

## 进程
对多进程支持的模块是`multiprocessing`和`subprocess`模块

### `multiprocessing`模块
- is_alive() 如果p人在运行，返回true
- join([timeout]) 等待进程p终止
- run()进程启动时运行的方法
- start()启动进程，这将代表进程的子进程，并调用该子进程中的run函数
- terminate()强制终止进程
- authkey 进程的身份验证键
- daemon 一个布尔标识，指示进程是否是后台进程
- exitcode 进程的整数退出代码
- name 进程的名称
- pid 进程的整数进程id
- [多进程python - Pastebin.com](https://pastebin.com/b4eENfQR)

### 进程池
<p>Pool({numprocess[, initializer[, initargs]]])-->进程数(默认cpu_count()的值); 每个工作进程启动时要执行的可调用对象; 传递给initializer的参数元组(默认为none)</p>

- apply(func[,args[,kwargs]])，在一个池的公作进程中执行函数`(*args, **kwargs)`，然后返回结果。
- apply_async(func[,args[,kwargs[,callback]]])，在一个池中异步执行函数`(*args, **kwargs)`，然后返回结果
- close() 关闭进程池
- join() 等待所有结果完成后退出，只和close，terminate混合使用
- imap( func ， iterable[ ,chunksize] )， map()函数的版本之一，返回迭代器而非结果列表
- imap_unordered(func，iterable [，chunksize] ) 与上访的一样结果的顺序根据从工作进程接收时间而定
- map_async( func ， iterable [ ，chunksize [，callback]] ) 同map函数，返回结果异步
- terminate() 立即终止所有进程，不执行清理和挂起任务。
- get([timeout]) 返回结果，如果有必要则等待结果到达
- ready() 调用完成返回true
- successful(） 调用完没有引发异常，返回true
- wait([timeout]) 等待结果变为可用
- [进程池 - Pastebin.com](https://pastebin.com/35g9i7C4)

### 队列
普通的进程之间即便是全局变量发生改变也无法实现信息通信，但是队列可以实现
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwODc1NDEwNzksLTIwNTU1Njk2NCw3ND
Q1MjExOTEsMTg2MzcwMjYyMl19
-->