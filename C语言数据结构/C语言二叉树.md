
## 种一颗赛博柠檬树（二叉树数据结构的讲解）
### 为什么要使用二叉树结构？
二叉树是一种非常高效的数据结构，它具有以下几个优点，使得它在许多应用场景中非常有用：
1. **快速查找**：二叉搜索树（BST）可以快速查找一个特定的值。在最坏的情况下，查找操作的时间复杂度为O(n)，但在平均和最佳情况下，时间复杂度为O(log n)。这是因为BST的每个节点都有两个子节点，并且节点的值按照某种顺序排列，使得可以快速定位到目标值。
2. **有序性**：二叉树可以是有序的，这使得它们非常适合排序和查找。例如，二叉搜索树中的节点值是有序的，这使得我们可以使用中序遍历来获取有序的值序列。
3. **高效插入和删除**：二叉树结构使得插入和删除操作也非常高效。在最坏的情况下，插入和删除操作的时间复杂度为O(n)，但在平均和最佳情况下，时间复杂度为O(log n)。
4. **多用途**：二叉树可以用于实现多种数据结构，如平衡树（AVL树、红黑树等）、优先队列（堆）、并查集等。
5. **空间效率**：与数组相比，二叉树提供了更好的空间效率，因为它们不需要预先分配固定大小的内存空间。
6. **支持多种遍历方式**：二叉树支持前序遍历、中序遍历、后序遍历等多种遍历方式，这使得它们可以灵活地应用于不同的场景。
7. **优先队列**：二叉堆是一种特殊的二叉树，它可以作为优先队列使用，提供高效的插入和删除操作。
尽管二叉树具有许多优点，但也存在一些缺点，例如，在极端情况下，插入和删除操作的时间复杂度可能较高，以及二叉树通常需要额外的空间来存储指针。此外，维护二叉树（如平衡树）的平衡状态可能会增加额外的复杂性和计算成本。

### 什么是二叉树
```mermaid
graph LR
A(父节点<br>左节点 右节点) --> B(子节点一<br>左节点 右节点)
A --> C(子节点二<br>左节点 右节点)
B --> D(孙节点一<br>左节点 右节点)
B --> E(孙节点二<br>左节点 右节点)
C --> F(曾孙节点一<br>左节点 右节点)
C --> G(曾孙节点二<br>左节点 右节点)

```
像这样的一个树状结构，由一个父节点开始，每一个父节点产生两个子节点，每一个子节点产生两个孙节点，如此往复，每一个节点中都存储着一个结构体信息，按照一定的规律对树结构内的信息进行访问并输出，对于左侧的节点，可以采用左侧结构体指针进行访问，同理，右侧的节点也可以使用右结构体指针进行访问。通过二叉树的这种特点，循环n次以后我们就得到了一个含有2^N个信息的树状结构。

### 怎么实现二叉树
可以看出，思路与之前文章讲到的链表结构相仿，大体就是next指针从一个变成了left和right两个指针，也说明了知识的进步是循序渐进的。
1. - [ ] 首先，创建二叉树所需的结构体。
```c
typedef struct LemonTree{
    char id;
    struct LemonTree* left, *right;
} T; 
```
这里我们声明了这个结构体，它含有两个指针结构，分别对应以后的左节点和右节点，同时包含着一个属于自己的信息。

2. - [ ] 其次,我们开始对二叉树的写入
```c
T* getTree(){ //创建一个返回值为结构体指针的函数
    T *tree; // 创建一个访问指针
    char ch;// 接受对应要写入的值
    printf("输入A结束输入：");
    scanf(" %c", &ch); // 注意前面的空格，用于跳过任何前面的空白字符
    if(ch == 'A'){
        tree = NULL; // 读取到A我们返回null表明没有值写入。
    } else {
        tree = (struct LemonTree*)malloc(sizeof(struct LemonTree));
        tree -> id = ch; // 使用读取的字符
        tree -> left = getTree();
        tree -> right = getTree();
    }
    return tree;
}
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzODg4NDgyOTBdfQ==
-->