
# 也许能更新你对链表结构的理解

## 源码部分
```c
#include <stdio.h>
#include <stdlib.h>

// 节点结构
struct ListNode {
    int val;
    struct ListNode *next;
};

// 初始化节点
struct ListNode* createNode(int val) {
    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
    //链表内存空间申请前(struct ListNode*)不加括号，后面的要加
	//申请空间的大小为ListNode的大小 
    if (newNode == NULL) {//新的节点一定不是空节点，否则退出程序 
        printf("内存分配失败\n");
        exit(1);
    }
    newNode->val = val;//将传入的num[i]导入新节点的value中 
    newNode->next = NULL;//创建链表时还未链接到链表中 
    return newNode;
}

int main() {
    struct ListNode* head = NULL;//链表头指针悬空，链表当中没有节点 
    int nums[] = {1, 2, 3, 4, 5};//初始化一个数组写入链表 
    int size = sizeof(nums) / sizeof(nums[0]);//计算出数组元素个数 

    // 初始化链表
    if (size > 0) {
        head = createNode(nums[0]);//有了第一个节点的位置才能进行以后的节点位置跟进 
        struct ListNode* current = head;//用current指针追踪头节点的位置 
        for (int i = 1; i < size; i++) {
            current->next = createNode(nums[i]);//依次完成链表的创建，使用createNode函数创建一个value为num[i]的节点。
			//current的位置现在在头节点所以可以使用current访问next指针，即当前节点位置 
			//然后current->next指向newnode实际上就是将next指向新节点完成节点的介入  
            current = current->next;//更新current节点的位置到新添加的节点上，实际上current总是指向最后一个节点  标注一可视化讲解
        }
    }

    // 遍历链表
    printf("遍历链表: ");
    struct ListNode* temp = head;//这个之前的链表结构讲解过
    while (temp != NULL) {
        printf("%d ", temp->val);
        temp = temp->next;
    }
    putchar(10);

    // 查找节点
    int target = 3;//这个是我们要找的数
    temp = head;//从头节点开始访问，这里只能从头节点开始
    //因为头节点有数据存在，不同于之前的双向链表
    while (temp != NULL) {
        if (temp->val == target) {
            printf("查找到节点 %d\n", target);
            break;
        }
        temp = temp->next;
    }
    if (temp == NULL) {//没找到的话就是空指针了
        printf("未找到节点 %d\n", target);
    }

    // 插入节点
    int insertVal = 6;//要插入的数据叫做6，value值为6
    int insertIndex = 2;//他的索引叫做2
    struct ListNode* newNode = createNode(insertVal);//老样子创建一个新的节点，同时我们使用一个结构体指针接受他。
    if (insertIndex == 0) {//实际上对于大多数的链表结构，我见到的，都会把头节点单独列出来讨论，
        newNode->next = head;
        head = newNode;
    } else {
        temp = head;
        for (int i = 0; i < insertIndex - 1 && temp != NULL; i++) {
            temp = temp->next;
        }
        if (temp != NULL) {
            newNode->next = temp->next;
            temp->next = newNode;
        }
    }
    printf("在位置 %d 插入节点 %d\n", insertIndex, insertVal);
    printf("遍历链表: ");
    temp = head;
    while (temp != NULL) {
        printf("%d ", temp->val);
        temp = temp->next;
    }
    putchar(10);

    // 删除节点
    int deleteVal = 4;
    temp = head;
    if (temp != NULL && temp->val == deleteVal) {
        head = temp->next;
        free(temp);
    } else {
        while (temp != NULL && temp->next != NULL) {
            if (temp->next->val == deleteVal) {
                struct ListNode* deleteNode = temp->next;
                temp->next = temp->next->next;
                free(deleteNode);
                break;
            }
            temp = temp->next;
        }
    }
    printf("删除节点 %d\n", deleteVal);
    printf("遍历链表: ");
    temp = head;
    while (temp != NULL) {
        printf("%d ", temp->val);
        temp = temp->next;
    }
    putchar(10);

    // 清空链表
    while (head != NULL) {2
        struct ListNode* temp = head;
        head = head->next;
        free(temp);
    }
    printf("清空链表后: ");
    temp = head;
    while (temp != NULL) {
        printf("%d ", temp->val);
        temp = temp->next;
    }
    putchar(10);

    return 0;
}

```


## 标注一

- **初始状态**：`head -> [1]`, `current` 指向 `[1]`
- **第一次迭代**（i=1）：
  - 创建节点 `[2]`
  - 连接 `[1] -> [2]`
  - 移动 `current` 到 `[2]`
- **第二次迭代**（i=2）：
  - 创建节点 `[3]`
  - 连接 `[2] -> [3]`
  - 移动 `current` 到 `[3]`

如此继续，直到数组的所有元素都被添加到链表中。
通过 `current->next = createNode(nums[i]);` 这行代码，每次迭代都在链表末尾添加一个新节点，并通过更新 `current` 指针来保持 `current` 总是指向链表的最后一个节点。这种方式高效地构建了一个反映数组内容的单向链表。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTIzNTc0ODYzMl19
-->